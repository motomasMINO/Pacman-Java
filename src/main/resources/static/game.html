<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>PAC-MAN</title>
<style>
  #gameCanvas { background:#000; display:block; margin: 0 auto; }
  #overlay {
    position: absolute; color: #fff; font-family: monospace; font-size:20px;
    text-align:center;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="overlay"></div>

<script>
// 設定（マップに合わせる)
const tileSize = 32;
const cols = 19;
const rows = 21;
const boardWidth = cols * tileSize;   // 608
const boardHeight = rows * tileSize;  // 672

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = boardWidth;
canvas.height = boardHeight;

// 速度定数
const PACMAN_SPEED = Math.max(1, Math.floor(tileSize / 12)); // 例：32/12 ≒ 2
const GHOST_SPEED  = Math.max(1, Math.floor(tileSize / 12));

// 画像アセット
const assets = {
  images: {
    pacmanUp: '/images/pacmanUp.png',
    pacmanDown: '/images/pacmanDown.png',
    pacmanLeft: '/images/pacmanLeft.png',
    pacmanRight: '/images/pacmanRight.png',
    wall: '/images/wall.png',
    power: '/images/powerFood.png',
    cherry: '/images/cherry.png',
    ghostBlue: '/images/blueGhost.png',
    ghostOrange: '/images/orangeGhost.png',
    ghostPink: '/images/pinkGhost.png',
    ghostRed: '/images/redGhost.png',
    ghostScared: '/images/scaredGhost.png'
  }
};

// BGM/SE
const ghostMoving = new Audio("/sounds/ghostMoving.wav");
ghostMoving.loop = true;
ghostMoving.volume = 0.5;

const eat = new Audio("/sounds/Pacman_Eat.wav");
eat.volume = 0.5;

const eatGhost = new Audio("/sounds/eatGhost.wav");
eatGhost.volume = 0.5;

const eatFruit = new Audio("/sounds/Eat-Fruit.wav");
eatFruit.volume = 0.5;

const lose = new Audio("/sounds/Pacman_Lose.wav");
lose.volume = 0.5;

const extraLife = new Audio("/sounds/Extend.wav");
extraLife.volume = 0.5;

const ghostScaring = new Audio("/sounds/ghostScaring.wav");
ghostScaring.loop = true;
ghostScaring.volume = 0.5;

const start = new Audio("/sounds/gameStart.wav");
start.volume = 0.5;

// プリロード用ヘルパー
function loadImage(src){
  return new Promise((res, rej) => {
    const i = new Image();
    i.onload = () => res(i);
    i.onerror = (err) => rej(err);
    i.src = src;
  });
}

// マップ
const tileMap = [
"XXXXXXXXXXXXXXXXXXX",
"X        X        X",
"X@XX XXX X XXX XX@X",
"X                 X",
"X XX X XXXXX X XX X",
"X    X       X    X",
"XXXX XXXX XXXX XXXX",
"OOOX X       X XOOO",
"XXXX X XXrXX X XXXX",
"O      XbpoX      O",
"XXXX X XXXXX X XXXX",
"OOOX X       X XOOO",
"XXXX X XXXXX X XXXX",
"X        X        X",
"X XX XXX X XXX XX X",
"X@ X     P     X @X",
"XX X X XXXXX X X XX",
"X    X   X   X    X",
"X XXXXXX X XXXXXX X",
"X                 X",
"XXXXXXXXXXXXXXXXXXX"
];

// ゲーム状態
let images = {};
let sounds = {};
let walls = [];
let foods = [];
let powerFoods = [];
let ghosts = [];
let pacman = null;
let cherry = null;
let eatenFoodCount = 0;
let score = 0;
let lives = 3;
let rounds = 1;
let gameStarted = false;
let gameOver = false;
let nextExtraLifeScore = 10000;
let scaredUntil = 0;
let _ghostScaredTO = null;
let _cherryTO = null;
let startDelayTO = null;

// チェリー獲得時に表示するスコア表示管理
let cherryScoreVisible = false;
let cherryScoreExpires = 0;
let cherryScoreText = "100";
let cherryScoreX = 280;
let cherryScoreY = 380;

class Block {
  constructor(x,y,w,h,img=null,points=0){
    this.x=x; 
    this.y=y; 
    this.w=w; 
    this.h=h; 
    this.img=img; 
    this.originalImg = img;
    this.alive=true; 
    this.points=points;
    this.vx=0; 
    this.vy=0; 
    this.direction='L'; 
    this.isScared=false; 
    this.startX=x; 
    this.startY=y;
  }
  reset(){ 
    this.x=this.startX; 
    this.y=this.startY; 
    this.isScared=false; 
    this.alive=true; 
    this.img = this.originalImg;
    this.vx=0;
    this.vy=0;
  }
}

// 初期化（画像読み込み → マップ生成）
async function init(){
  // 画像読み込み
  const imgPromises = Object.entries(assets.images).map(([k,v]) => loadImage(v).then(img => images[k]=img));
  await Promise.all(imgPromises);
  buildMap();
  draw();
  start.currentTime = 0;
  start.play();

  // 5秒後に自動スタート
  if(startDelayTO) {
    clearTimeout(startDelayTO);
    startDelayTO = null;
  }
  startDelayTO = setTimeout(() => {
    if(!gameStarted && !gameOver) {
      gameStarted = true;
      try {
        ghostMoving.currentTime = 0;
        ghostMoving.play();
      } catch(e) {}
      gameLoop();
    }
    startDelayTO = null;
  }, 6000);
}

// マップ構築
function buildMap(){
  walls = []; 
  foods = []; 
  powerFoods = []; 
  ghosts = []; 
  pacman = null; 
  cherry = null; 
  eatenFoodCount = 0;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const ch = tileMap[r][c];
      const x = c*tileSize, y = r*tileSize;
      if(ch==='X'){ 
        walls.push(new Block(x,y,tileSize,tileSize, images.wall)); 
      }
      else if(ch===' '){ 
        foods.push(new Block(x+14,y+14,4,4,null,10)); 
      }
      else if(ch==='@'){ 
        powerFoods.push(new Block(x+10,y+10,12,12, images.power,50)); 
      }
      else if(ch==='b'){ 
        ghosts.push(new Block(x,y,tileSize,tileSize, images.ghostBlue)); 
      }
      else if(ch==='o'){ 
        ghosts.push(new Block(x,y,tileSize,tileSize, images.ghostOrange)); 
      }
      else if(ch==='p'){ 
        ghosts.push(new Block(x,y,tileSize,tileSize, images.ghostPink)); 
      }
      else if(ch==='r'){ 
        ghosts.push(new Block(x,y,tileSize,tileSize, images.ghostRed)); 
      }
      else if(ch==='P'){ 
        pacman = new Block(x,y,tileSize,tileSize, images.pacmanLeft); 
        pacman.vx=0; 
        pacman.vy=0; 
      }
    }
  }

  // ゴースト初期速度設定
  ghosts.forEach(g => {
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    const d = dirs[Math.floor(Math.random()*dirs.length)];
    g.vx = d[0]*Math.max(1, tileSize/8);
    g.vy = d[1]*Math.max(1, tileSize/8);
    g.startX = g.x; 
    g.startY = g.y;
  });
}

// ヘルパー: 衝突判定
function rectCollision(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

// 指定方向 (dx,dy) に speed ピクセル移動したとき壁と衝突するかを判定する
function canMove(dx, dy) {
  const speed = PACMAN_SPEED; // move speed と同じ値を使う
  const testRect = {
    x: pacman.x + dx * speed,
    y: pacman.y + dy * speed,
    w: pacman.w,
    h: pacman.h
  };
  for (const w of walls) {
    if (testRect.x < w.x + w.w && testRect.x + testRect.w > w.x &&
        testRect.y < w.y + w.h && testRect.y + testRect.h > w.y) {
      return false; // 移動不可（ぶつかる）
    }
  }
  // 画面端の扱い: ワープがあるなら画面端チェックは不要にするか下記で許可
  // ここでは端に出すこと自体は許可（既存のワープ処理で対応）
  return true;
}

// 描画
function draw(){
  ctx.clearRect(0,0,boardWidth,boardHeight);

  // 壁
  walls.forEach(w => {
    if(w.img) ctx.drawImage(w.img, w.x, w.y, w.w, w.h);
    else { 
      ctx.fillStyle = '#222'; 
      ctx.fillRect(w.x,w.y,w.w,w.h); 
    }
  });

  // エサ
  ctx.fillStyle = '#fff';
  foods.forEach(f => ctx.fillRect(f.x,f.y,f.w,f.h));

  // パワーエサ
  powerFoods.forEach(p => { 
    if(p.img) ctx.drawImage(p.img,p.x,p.y,p.w,p.h); 
    else ctx.fillStyle='yellow'; 
  });

  // チェリー
  if(cherry && cherry.img) ctx.drawImage(cherry.img, cherry.x, cherry.y, cherry.w, cherry.h);

  // ゴースト
  ghosts.forEach(g => {
    if(!g.alive) return;
    const img = g.isScared ? images.ghostScared : g.img;
    ctx.drawImage(img, g.x, g.y, g.w, g.h);
  });

  // パックマン
  if(pacman && pacman.alive) {
    ctx.drawImage(pacman.img, pacman.x, pacman.y, pacman.w, pacman.h);
  }

  // HUD
  ctx.fillStyle = '#fff';
  ctx.font = '18px monospace';
  ctx.fillText("SCORE: " + score, 10, 20);
  ctx.fillText("LIFE x " + lives, 10, 40);
  ctx.fillText("ROUND " + rounds, boardWidth - 120, 20);

  // チェリースコア表示
  if(cherryScoreVisible) {
    // 期限切れチェック（念のため）
    if(Date.now() > cherryScoreExpires) {
      cherryScoreVisible = false;
    } else {
      ctx.fillStyle = "pink";
      ctx.font = "30px monospace";
      ctx.fillText(cherryScoreText, cherryScoreX, cherryScoreY);
    }
  }

  // READY!の表示
  if(!gameStarted && !gameOver) {
    ctx.fillStyle="yellow";
    ctx.font="30px monospace";
    ctx.fillText("READY!", 260, 380);
  }

  // GAME OVERの表示
  if(gameOver) {
    ctx.fillStyle="red";
    ctx.font="30px monospace";
    ctx.fillText("GAME OVER", 235, 380);
  }
}

// ゲームロジック更新（move）
function update(){
  // イジケ状態の終了チェック
  if (scaredUntil && Date.now() > scaredUntil) {
     endScaredMode();
  }

  if(!gameStarted || gameOver) return;

  // パックマン移動
  pacman.x += pacman.vx;
  pacman.y += pacman.vy;

  // パックマンワープ
  if(pacman.x < -pacman.w) pacman.x = boardWidth;
  if(pacman.x > boardWidth) pacman.x = -pacman.w;

  // 壁衝突
  for(const w of walls){
    if(rectCollision(pacman, w)){
      pacman.x -= pacman.vx;
      pacman.y -= pacman.vy;
      pacman.vx = 0; pacman.vy = 0;
      break;
    }
  }

  // エサ
  for(let i = foods.length - 1; i >= 0; i--){
    if(rectCollision(pacman, foods[i])){
      score += foods[i].points;
      foods.splice(i,1);
      eat.currentTime = 0;
      eat.play();
      eatenFoodCount++;
      if(score >= nextExtraLifeScore){ 
        lives++; 
        extraLife.currentTime = 0;
        extraLife.play(); 
        nextExtraLifeScore += 10000; 
      }
      // チェリーのスポーン
      if(eatenFoodCount === 70 || eatenFoodCount === 170){ 
        spawnCherry(); 
      }
    }
  }

  // パワーエサ
  for(let i = powerFoods.length - 1; i >= 0; i--){
    if(rectCollision(pacman, powerFoods[i])){
      score += powerFoods[i].points;
      powerFoods.splice(i,1);
      eat.currentTime = 0;
      eat.play();
      eatenFoodCount++;

      startScaredMode(10000); // 10秒(再度取れば+10秒延長)

      // 10,000点ごとに1UP
      if(score >= nextExtraLifeScore){ 
        lives++; 
        extraLife.currentTime = 0;
        extraLife.play(); 
        nextExtraLifeScore += 10000; 
      }
    }
  }

  // チェリー
  if(cherry && rectCollision(pacman, cherry)){
    score += 100;
    eatFruit.currentTime = 0;
    eatFruit.play();
    cherry = null;

    // 中央に "100" を 5秒間表示
    cherryScoreVisible = true;
    cherryScoreExpires = Date.now() + 5000; // 5秒
    cherryScoreText = "100";
    // 必要なら表示位置をチェリー位置 or 固定中央にする
    cherryScoreX = 280;
    cherryScoreY = 380;

    // 既存のタイマー（存在すれば）をクリア
    if (_cherryTO) {
       clearTimeout(_cherryTO);
       _cherryTO = null;
    }
    // （オプション）5秒後に明示的に消すタイマーもセット
    _cherryTO = setTimeout(() => {
      cherryScoreVisible = false;
      cherryScoreExpires = 0;
      _cherryTO = null;
    }, 5000);
  }

  // ゴースト移動
  ghosts.forEach(g => {
    if(!g.alive) return;
    g.x += g.vx;
    g.y += g.vy;
    let collided=false;
    for(const w of walls){ 
      if(rectCollision(g,w)){ 
        collided = true; 
        break; 
      } 
    }
    if(collided || g.x < 0 || g.x + g.w > boardWidth || Math.random() < 0.02){
      // 壁にぶつかった or 画面外 or ランダムで方向転換
      g.x -= g.vx;
      g.y -= g.vy;
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      const d = dirs[Math.floor(Math.random()*dirs.length)];
      g.vx = d[0] * GHOST_SPEED;
      g.vy = d[1] * GHOST_SPEED;
    }
    // パックマンとの衝突
    if(rectCollision(g, pacman)){
      if(g.isScared){
        // ゴーストを食べたとき
        score += 200;
        eatGhost.currentTime = 0; 
        eatGhost.play();
        g.reset();
        g.isScared=false;
        if(score >= nextExtraLifeScore){ 
           lives++;
           extraLife.currentTime = 0;
           extraLife.play();
           nextExtraLifeScore += 10000; 
          }
      } else {
        // ミス時
        lives--;
        lose.currentTime = 0;
        lose.play();
        cherry = null;
        endScaredMode();
        
        clearTimeout(window._ghostScaredTO);
        
        if(lives == 0){
          gameOver = true;
          sendScoreToServer();
          freezeEntities();
        } else {
          // ライフが残っているなら通常のリセット（位置を戻す）
          ghosts.forEach(h => { h.reset(); });
          pacman.x = pacman.startX;
          pacman.y = pacman.startY;
          pacman.vx = pacman.vy = 0;
        }
      }
    }
  });

  // すべてのエサを食べたらラウンドクリア
  if(foods.length === 0){
    rounds++;
    buildMap();
    ghostScaring.pause();
    ghostScaring.currentTime = 0;
    ghostMoving.currentTime = 0;
    ghostMoving.play();
  }
}

function startScaredMode(durationMs = 10000) {
  scaredUntil = Date.now() + durationMs;
  // 画像とフラグを切り替え
  ghosts.forEach(g => {
    if (g.alive) {
      g.isScared = true;
      g.img = images.ghostScared;
    }
  });
  // 音：ghostMoving を止めて ghostScaring を再生
  try { 
    ghostMoving.pause(); 
    ghostMoving.currentTime = 0; 
  } catch(e){}
  try { 
    ghostScaring.currentTime = 0; 
    ghostScaring.play(); 
  } catch(e){}
}

function endScaredMode() {
  scaredUntil = 0;
  ghosts.forEach(g => {
    if (g.alive) {
      g.isScared = false;
      g.img = g.originalImg; // 元の画像で復帰
    }
  });
  // 音を戻す
  try { 
    ghostScaring.pause(); 
    ghostScaring.currentTime = 0; 
  } catch(e){}
  try {
     ghostMoving.currentTime = 0; 
     ghostMoving.play(); 
    } catch(e){}
}

// チェリースポーン
function spawnCherry(){
  const x = Math.floor(cols/2) * tileSize - tileSize/2 + 15;
  const y = Math.floor(rows/2) * tileSize - tileSize/2 + 50;
  cherry = new Block(x,y,tileSize,tileSize, images.cherry);
  // 10秒で消える
  clearTimeout(window._cherryTO);
  window._cherryTO = setTimeout(()=>{ cherry=null; }, 10000);
}

function freezeEntities() {
  // パックマン停止
  if (pacman) { pacman.vx = 0; pacman.vy = 0; }
  // ゴースト停止
  ghosts.forEach(g => { g.vx = 0; g.vy = 0; });
  // BGM停止など
  try { 
    ghostMoving.pause(); 
    ghostMoving.currentTime = 0; 
  } catch(e){}
  try { 
    ghostScaring.pause(); 
    ghostScaring.currentTime = 0; 
  } catch(e){}
}

// サーバにスコアを送る
function sendScoreToServer(){
  fetch('/api/scores', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ player: 'Player1', score: score })
  }).then(()=> console.log('score submitted')).catch(e=>console.warn('score submit failed', e));
}

// 入力ハンドラ
window.addEventListener('keydown', (e) => {
  if(e.code === 'Space' && !e.repeat){
    if(!gameStarted && !gameOver){
      // 自動スタートタイマーが残っていればクリア(重複防止)
      if(startDelayTO) {
        clearTimeout(startDelayTO);
        startDelayTO = null;
      }

      gameStarted = true;
      try {
        ghostMoving.currentTime = 0;
        ghostMoving.play();
      } catch(e){}
      gameLoop();
      return;
    }
    if(gameOver){
      // タイトル画面へ戻る
      window.location.href = '/'; // index.html
      return;
    }
  }

  if(!gameStarted) 
  return;

  if(e.code === 'ArrowUp'){ 
    if(canMove(0, -1)){
      pacman.vx = 0; 
      pacman.vy = -PACMAN_SPEED; 
      pacman.img = images.pacmanUp; 
    }
  }
  if(e.code === 'ArrowDown'){
    if(canMove(0, 1)){ 
      pacman.vx = 0; 
      pacman.vy = PACMAN_SPEED; 
      pacman.img = images.pacmanDown;
    } 
  }
  if(e.code === 'ArrowLeft'){
    if(canMove(-1, 0)){ 
      pacman.vx = -PACMAN_SPEED; 
      pacman.vy = 0; 
      pacman.img = images.pacmanLeft;
    } 
  }
  if(e.code === 'ArrowRight'){
    if(canMove(1, 0)){ 
      pacman.vx = PACMAN_SPEED; 
      pacman.vy = 0; 
      pacman.img = images.pacmanRight;
    } 
  }
});

// メインループ
let loopId = null;
function gameLoop(){
  if(loopId) cancelAnimationFrame(loopId);
  function step(){
    update();
    draw();
    loopId = requestAnimationFrame(step);
  }
  step();
}

// 初期化呼び出し
init().catch(e=>{ console.error('init failed', e); });

</script>
</body>
</html>
